---
name: agent-builder
description: 为任何领域设计和构建 AI 智能体
---

**触发条件**：当用户：
- (1) 要求"创建智能体"、"构建助手"或"设计 AI 系统"时
- (2) 希望了解智能体架构、智能体模式或自主 AI 时
- (3) 需要有关能力、子智能体、规划或技能机制的帮助时
- (4) 询问有关 Claude Code、Cursor 或类似智能体内部工作原理时
- (5) 想要为业务、研究、创意或运营任务构建智能体时
关键词：智能体、助手、自主、工作流程、工具使用、多步骤、编排
---

# 智能体构建器

为任何领域构建 AI 智能体 - 客户服务、研究、运营、创意工作或专业业务流程。

## 核心哲学

> **模型已经知道如何成为智能体。你的工作是让开道路。**

智能体不是复杂的工程。它是一个简单的循环，邀请模型采取行动：

```
循环：
  模型看到：上下文 + 可用能力
  模型决定：行动或响应
  如果行动：执行能力，添加结果，继续
  如果响应：返回给用户
```

**就是这样。** 魔法不在代码中 - 而在模型中。你的代码只是提供机会。

## 三个要素

### 1. 能力（它能做什么？）

智能体可以执行的原子操作：搜索、读取、创建、发送、查询、修改。

**设计原则**：从 3-5 个能力开始。只有当智能体因缺少某个能力而持续失败时才添加更多。

### 2. 知识（它知道什么？）

按需注入的领域专业知识：政策、工作流程、最佳实践、模式。

**设计原则**：让知识可用，而不是强制要求。在相关时加载，而不是预先加载。

### 3. 上下文（发生了什么？）

对话历史 - 将行动连接成连贯行为的线程。

**设计原则**：上下文是宝贵的。隔离嘈杂的子任务。截断冗长的输出。保护清晰度。

## 智能体设计思考

在构建之前，理解：

- **目的**：这个智能体应该完成什么？
- **领域**：它在什么世界中运行？（客户服务、研究、运营、创意...）
- **能力**：哪 3-5 个行动是必不可少的？
- **知识**：它需要访问什么专业知识？
- **信任**：你可以将哪些决策委托给模型？

**重要提示**：信任模型。不要过度工程。不要预先指定工作流程。赋予它能力，让它推理。

## 渐进式复杂性

从简单开始。只有当实际使用揭示需要时才添加复杂性：

| 级别 | 添加内容 | 何时添加 |
|-------|-------------|----------------|
| 基础 | 3-5 个能力 | 始终从这里开始 |
| 规划 | 进度跟踪 | 多步骤任务失去连贯性时 |
| 子智能体 | 隔离的子智能体 | 探索污染上下文时 |
| 技能 | 按需知识 | 需要领域专业知识时 |

**大多数智能体永远不需要超过 Level 2。**

## 领域示例

**业务**：CRM 查询、电子邮件、日历、审批
**研究**：数据库搜索、文档分析、引用
**运营**：监控、工单、通知、升级
**创意**：资产生成、编辑、协作、审查

模式是通用的。只有能力会改变。

## 关键原则

1. **模型就是智能体** - 代码只是运行循环
2. **能力启用** - 它能做什么
3. **知识告知** - 它知道如何做什么
4. **约束聚焦** - 限制创造清晰度
5. **信任解放** - 让模型推理
6. **迭代揭示** - 从最小开始，从使用中进化

## 反模式

| 模式 | 问题 | 解决方案 |
|---------|---------|----------|
| 过度工程 | 需求前的复杂性 | 从简单开始 |
| 过多能力 | 模型混乱 | 从 3-5 个开始 |
| 刚性工作流程 | 无法适应 | 让模型决定 |
| 前置知识 | 上下文膨胀 | 按需加载 |
| 微观管理 | 削弱智力 | 信任模型 |

## 资源

**哲学与理论**：
- `references/agent-philosophy.md` - 深入了解智能体为何有效

**实现**：
- `references/minimal-agent.py` - 完整工作智能体（~80 行）
- `references/tool-templates.py` - 能力定义
- `references/subagent-pattern.py` - 上下文隔离

**脚手架**：
- `scripts/init_agent.py` - 生成新的智能体项目

## 智能体思维方式

**从**："我如何让系统做 X？"
**到**："我如何使模型能够做 X？"

**从**："这个任务的工作流程是什么？"
**到**："什么能力有助于完成这个任务？"

最好的智能体代码几乎是无聊的。简单的循环。清晰的能力。干净的上下文。魔法不在代码中。

**赋予模型能力和知识。信任它来解决其余问题。**
