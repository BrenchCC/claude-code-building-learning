# 智能体哲学

> **模型已经知道如何成为智能体。你的工作是让开道路。**

## 核心洞察

剥离所有框架、所有库、所有架构模式。剩下的是什么？

一个循环。一个模型。一个行动的邀请。

智能体不是代码。智能体就是模型本身——一个在人类集体解决问题、推理和工具使用上训练过的庞大神经网络。代码仅仅为模型表达其智能体性提供了机会。

## 为什么这很重要

大多数智能体实现失败不是因为工程太少，而是因为工程太多。它们限制、规定、质疑自己试图利用的智能。

想想看：模型已经在数百万个解决问题的例子上接受了训练。它见过专家如何处理复杂任务，工具如何使用，计划如何形成和修订。这些知识已经存在，编码在数十亿个参数中。

你的工作不是教它如何思考。你的工作是给它行动的手段。

## 三个要素

### 1. 能力（工具）

能力回答：**智能体能做什么？**

它们是模型的手——它影响世界的能力。没有能力，模型只能说话。有了能力，它才能行动。

**设计原则**：每个能力应该是原子化的、清晰的、描述充分的。模型需要理解每个能力的作用，但不需要知道如何按顺序使用它们——它会弄明白的。

**常见错误**：能力过多。模型会混淆，开始使用错误的能力，或者因选择而瘫痪。从3-5个开始。只有当模型因缺少某个能力而持续无法完成任务时，才添加更多。

### 2. 知识（技能）

知识回答：**智能体知道什么？**

这是领域专业知识——将通用助手转变为领域专家的专门理解。客户服务智能体需要了解公司政策。研究智能体需要了解方法论。创意智能体需要了解风格指南。

**设计原则**：按需注入知识，而不是预先加载。模型不需要同时知道一切——只需要知道与当前任务相关的内容。渐进式披露保留了对重要内容的上下文。

**常见错误**：将所有可能的知识预先加载到系统提示中。这会浪费上下文，混淆模型，并使每次交互变得昂贵。相反，让知识可用但不是强制性的。

### 3. 上下文（对话）

上下文是交互的记忆——说了什么，尝试了什么，学到了什么。它是将单个行动连接成连贯行为的线索。

**设计原则**：上下文是宝贵的。保护它。隔离产生噪音的子任务。截断超出有用性的输出。当历史变长时进行总结。

**常见错误**：让上下文无限增长，填满探索细节、失败尝试和冗长的工具输出。最终模型无法在噪音中找到信号。

## 通用模式

每个有效的智能体——无论领域、框架或实现——都遵循相同的模式：

```
循环：
  模型看到：对话历史 + 可用能力
  模型决定：行动或响应
  如果行动：执行能力，结果添加到上下文，继续循环
  如果响应：返回答案，循环结束
```

这不是简化。这是实际的架构。其他一切都是优化。

## 为智能体性而设计

### 信任模型

最重要的原则：**信任模型**。

不要尝试预测每个边缘情况。不要构建复杂的决策树。不要预先指定工作流程。

模型比你能编写的任何规则系统都更擅长推理。你的条件逻辑会在边缘情况上失败。模型会通过推理解决它们。

**给模型能力和知识。让它弄清楚如何使用它们。**

### 约束赋能

这看起来自相矛盾，但约束不会限制智能体——它们会聚焦智能体。

"只有一个任务在进行中"的待办列表迫使顺序聚焦。"只读访问"的子智能体防止意外修改。"100字以下"的响应要求清晰。

最好的约束是防止模型迷路的约束，而不是微观管理其方法的约束。

### 渐进式复杂性

永远不要预先构建所有内容。

```
Level 0: 模型 + 一个能力
Level 1: 模型 + 3-5个能力
Level 2: 模型 + 能力 + 规划
Level 3: 模型 + 能力 + 规划 + 子智能体
Level 4: 模型 + 能力 + 规划 + 子智能体 + 技能
```

从可能有效的最低级别开始。只有当实际使用揭示需要时才向上移动。大多数智能体永远不需要超过Level 2。

## 智能体思维方式

构建智能体需要思维转变：

**从**："我如何让系统做X？"
**到**："我如何使模型能够做X？"

**从**："当用户说Y时应该发生什么？"
**到**："什么能力有助于解决Y？"

**从**："这个任务的工作流程是什么？"
**到**："模型需要什么来弄清楚工作流程？"

最好的智能体代码几乎是无聊的。简单的循环。清晰的能力定义。干净的上下文管理。魔法不在代码中——而在模型中。

## 哲学基础

### 作为涌现智能体的模型

在人类文本上训练的语言模型不仅学习了语言，还学习了思维模式。它们吸收了人类如何解决问题、使用工具和实现目标。这是涌现的智能体性——不是编程的，而是学习的。

当你赋予模型能力时，你不是在教它成为智能体。你是在允许它表达它已有的智能体性。

### 作为解放的循环

智能体循环看似简单：获取响应，检查工具使用，执行，重复。但这种简单性就是它的力量。

循环不限制模型到特定序列。它不强制执行特定工作流程。它只是说："你有能力。按你认为合适的方式使用。我会执行你的请求并显示结果。"

这是解放，不是限制。

### 作为表达的能力

你提供的每个能力都是模型的一种表达形式。"读取文件"让它看到。"写入文件"让它创建。"搜索"让它探索。"发送消息"让它沟通。

智能体设计的艺术在于选择启用哪些表达形式。太少了，模型会沉默。太多了，它会胡言乱语。

## 结论

智能体就是模型。代码只是循环。你的工作是让开道路。

给模型清晰的能力。在需要时提供知识。保护上下文免受噪音影响。相信模型会解决其余问题。

就是这样。这就是哲学。

其他一切都是优化。
